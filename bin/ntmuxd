#!/usr/bin/env node
"use strict";

const net = require('net');
const os = require('os');
const fs = require('fs');
const path = require('path');
const pty = require('node-pty-prebuilt-multiarch');

const SOCKET_PATH = path.join(os.homedir(), '.ntmuxd.sock');

/**
 * Session store: name -> session object
 * session: { name, pty, createdAt, cwd, cols, rows, bufferLines: string[], maxLines }
 */
const sessions = new Map();

function ensureSocketRemoved() {
  try {
    if (fs.existsSync(SOCKET_PATH)) fs.unlinkSync(SOCKET_PATH);
  } catch (_) {}
}

function createSession({ name, cols = 120, rows = 30, cwd = process.cwd() }) {
  if (!name) throw new Error('Session name required');
  if (sessions.has(name)) throw new Error('Session already exists');
  const shell = process.env.SHELL || '/bin/zsh';
  const child = pty.spawn(shell, [], {
    name: 'xterm-color',
    cols,
    rows,
    cwd,
    env: process.env,
  });
  const bufferLines = [];
  const maxLines = 2000;
  child.onData((data) => {
    const parts = data.split(/\r?\n/);
    // Append; keep last maxLines
    if (parts.length === 1) {
      // No newline; treat as a line fragment
      const last = bufferLines.pop() || '';
      bufferLines.push(last + parts[0]);
    } else {
      // Merge first with last fragment
      const first = parts.shift();
      const prev = bufferLines.pop() || '';
      bufferLines.push(prev + first);
      // Push remaining lines
      for (const line of parts) bufferLines.push(line);
    }
    if (bufferLines.length > maxLines) bufferLines.splice(0, bufferLines.length - maxLines);
  });
  const session = { name, pty: child, createdAt: new Date(), cwd, cols, rows, bufferLines, maxLines };
  sessions.set(name, session);
  child.onExit(() => sessions.delete(name));
  return session;
}

function listSessions() {
  return Array.from(sessions.values()).map((s) => ({
    session_name: s.name,
    session_created_string: s.createdAt.toISOString(),
    session_path: s.cwd,
  }));
}

function getSession(name) {
  const s = sessions.get(name);
  if (!s) throw new Error('no such session');
  return s;
}

function capturePane({ target, start = null, includeEscapes = true }) {
  const s = getSession(target);
  const lines = s.bufferLines;
  let slice;
  if (typeof start === 'number' && start < 0) {
    const n = Math.abs(start);
    slice = lines.slice(-n);
  } else {
    slice = lines.slice(-200);
  }
  // Join with newlines. includeEscapes is ignored because PTY data already includes ANSI.
  return slice.join('\n');
}

function resizeWindow({ target, cols, rows }) {
  const s = getSession(target);
  if (typeof cols === 'number' && typeof rows === 'number') {
    s.pty.resize(cols, rows);
    s.cols = cols; s.rows = rows;
  }
}

function killSession({ target }) {
  const s = getSession(target);
  try { s.pty.kill(); } catch (_) {}
  sessions.delete(target);
}

function displayFormat({ target, format }) {
  const s = getSession(target);
  const subs = {
    '#{session_name}': s.name,
    '#{window_width}': String(s.cols),
    '#{window_height}': String(s.rows),
    '#{pane_width}': String(s.cols),
    '#{pane_height}': String(s.rows),
  };
  let out = format;
  for (const [k, v] of Object.entries(subs)) out = out.split(k).join(v);
  return out;
}

function handleRequest(msg) {
  const { cmd } = msg || {};
  switch (cmd) {
    case 'new-session':
      createSession(msg);
      return { ok: true };
    case 'list-sessions':
      return { ok: true, sessions: listSessions() };
    case 'capture-pane':
      return { ok: true, data: capturePane(msg) };
    case 'resize-window':
      resizeWindow(msg); return { ok: true };
    case 'kill-session':
      killSession(msg); return { ok: true };
    case 'has-session':
      try { getSession(msg.target); return { ok: true }; } catch (_) { return { ok: false }; }
    case 'display-p':
      return { ok: true, data: displayFormat(msg) };
    default:
      return { ok: false, error: 'unknown cmd' };
  }
}

function startServer() {
  ensureSocketRemoved();
  const server = net.createServer((socket) => {
    let buf = '';
    socket.setEncoding('utf8');
    socket.on('data', (chunk) => {
      buf += chunk;
      let idx;
      while ((idx = buf.indexOf('\n')) !== -1) {
        const line = buf.slice(0, idx); buf = buf.slice(idx + 1);
        let req;
        try { req = JSON.parse(line); } catch (e) { socket.write(JSON.stringify({ ok: false, error: 'bad json' }) + '\n'); continue; }
        const res = handleRequest(req);
        socket.write(JSON.stringify(res) + '\n');
      }
    });
  });
  server.listen(SOCKET_PATH, () => {
    try { fs.chmodSync(SOCKET_PATH, 0o600); } catch (_) {}
    console.log('ntmuxd listening at', SOCKET_PATH);
  });
  server.on('error', (err) => {
    console.error('ntmuxd error', err);
    process.exit(1);
  });
}

startServer();


